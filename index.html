<!DOCTYPE html>
<html>
<head>
  <title>World Tour</title>
  <style type="text/css">
    * { box-sizing: border-box; font-family: Verdana, sans-serif; font-size: 14px; }
    html, body { height: 100%; margin: 0; }
  </style>
</head>
<body>
  <div style="width:360px; position: fixed; overflow: auto; border-right: 3px solid skyblue; height: 100%; padding: 10px;">
    <div><input type="text" v-model="tableFilterText" placeholder="Filter Tables" style="width:100%;" class="filterText"></div>
    <div v-if="allTables.length > 0">
      <div v-for="tableName in filteredTables" v-on:click="addTable(tableName)" style="padding:2px 0px;cursor:pointer;">{{tableName}}</div>
    </div>
  </div>
  <div style="margin-left: 360px; padding: 10px;">
    <canvas width="800" height="800" style="border:3px solid skyblue;"></canvas>
    <div class="messages"></div>
  </div>

<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script src="https://unpkg.com/topojson@3"></script>
<script type="module">
  // https://observablehq.com/@d3/world-tour
  async function main(){
    const canvas = document.querySelector("canvas");
    const world = await d3.json("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json");
    const land = topojson.feature(world, world.objects.land);
    const borders = topojson.mesh(world, world.objects.countries, (a, b) => a !== b);
    const countries = topojson.feature(world, world.objects.countries).features;
    const sphere = ({type: "Sphere"});
    const tilt = 20;
    const width = canvas.width;
    const height = Math.min(width, canvas.height);
    let name = "";

    class Versor {
      static fromAngles([l, p, g]) {
        l *= Math.PI / 360;
        p *= Math.PI / 360;
        g *= Math.PI / 360;
        const sl = Math.sin(l), cl = Math.cos(l);
        const sp = Math.sin(p), cp = Math.cos(p);
        const sg = Math.sin(g), cg = Math.cos(g);
        return [
          cl * cp * cg + sl * sp * sg,
          sl * cp * cg - cl * sp * sg,
          cl * sp * cg + sl * cp * sg,
          cl * cp * sg - sl * sp * cg
        ];
      }
      static toAngles([a, b, c, d]) {
        return [
          Math.atan2(2 * (a * b + c * d), 1 - 2 * (b * b + c * c)) * 180 / Math.PI,
          Math.asin(Math.max(-1, Math.min(1, 2 * (a * c - d * b)))) * 180 / Math.PI,
          Math.atan2(2 * (a * d + b * c), 1 - 2 * (c * c + d * d)) * 180 / Math.PI
        ];
      }
      static interpolateAngles(a, b) {
        const i = Versor.interpolate(Versor.fromAngles(a), Versor.fromAngles(b));
        return t => Versor.toAngles(i(t));
      }
      static interpolateLinear([a1, b1, c1, d1], [a2, b2, c2, d2]) {
        a2 -= a1, b2 -= b1, c2 -= c1, d2 -= d1;
        const x = new Array(4);
        return t => {
          const l = Math.hypot(x[0] = a1 + a2 * t, x[1] = b1 + b2 * t, x[2] = c1 + c2 * t, x[3] = d1 + d2 * t);
          x[0] /= l, x[1] /= l, x[2] /= l, x[3] /= l;
          return x;
        };
      }
      static interpolate([a1, b1, c1, d1], [a2, b2, c2, d2]) {
        let dot = a1 * a2 + b1 * b2 + c1 * c2 + d1 * d2;
        if (dot < 0) a2 = -a2, b2 = -b2, c2 = -c2, d2 = -d2, dot = -dot;
        if (dot > 0.9995) return Versor.interpolateLinear([a1, b1, c1, d1], [a2, b2, c2, d2]);
        const theta0 = Math.acos(Math.max(-1, Math.min(1, dot)));
        const x = new Array(4);
        const l = Math.hypot(a2 -= a1 * dot, b2 -= b1 * dot, c2 -= c1 * dot, d2 -= d1 * dot);
        a2 /= l, b2 /= l, c2 /= l, d2 /= l;
        return t => {
          const theta = theta0 * t;
          const s = Math.sin(theta);
          const c = Math.cos(theta);
          x[0] = a1 * c + a2 * s;
          x[1] = b1 * c + b2 * s;
          x[2] = c1 * c + c2 * s;
          x[3] = d1 * c + d2 * s;
          return x;
        };
      }
    }

    const context = canvas.getContext("2d");
    const projection = d3.geoOrthographic().fitExtent([[10, 10], [width - 10, height - 10]], sphere);
    const path = d3.geoPath(projection, context);

    function render(country, arc) {
      context.clearRect(0, 0, width, height);
      context.beginPath(), path(land), context.fillStyle = "#ccc", context.fill();
      context.beginPath(), path(country), context.fillStyle = "#f00", context.fill();
      context.beginPath(), path(borders), context.strokeStyle = "#fff", context.lineWidth = 0.5, context.stroke();
      context.beginPath(), path(sphere), context.strokeStyle = "#000", context.lineWidth = 1.5, context.stroke();
      context.beginPath(), path(arc), context.stroke();
      return context.canvas;
    }

    let p1, p2 = [0, 0], r1, r2 = [0, 0, 0];
    const messages = document.querySelector(".messages");
    const filterText = document.querySelector(".filterText");
    for (const country of countries) {
      // Use the filter text box as a pause button
      while (!!filterText.value){
        await d3.transition().delay(250).end();
      }
      name = country.properties.name;
      messages.textContent += name+"\n";
      render(country);

      p1 = p2, p2 = d3.geoCentroid(country);
      r1 = r2, r2 = [-p2[0], tilt - p2[1], 0];
      const ip = d3.geoInterpolate(p1, p2);
      const iv = Versor.interpolateAngles(r1, r2);

      await d3.transition() // create a transition with no selected elements
          .duration(1250) // set the transition duration
          .tween("render", () => t => {
            projection.rotate(iv(t));
            render(country, {type: "LineString", coordinates: [p1, ip(t)]});
          }) // assign the result of the meta function to be called for every frame of the transition, under the given name
          .transition() // chain a new transition, inheriting the previous transition's duration and selection
          .tween("render", () => t => {
            render(country, {type: "LineString", coordinates: [ip(t), p2]});
          }) // as above, assign a named function for every frame of the transition
          .end(); // return a promise that will resolve when the transition is complete
    }
  }
  main();
</script>
</body>
</html>